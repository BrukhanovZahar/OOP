___

# Лабораторная работа 06

___

## Оглавление

1. [Цель](#цель)
2. [Порядок выполнения работы](#порядок-выполнения-работы)
3. [Требования к программе](#требования-к-программе)
4. [Вариант задания](#вариант-задания)
5. [Сборка программы](#сборка-программы)
6. [Тесты](#тесты)
7. [Комментарий](#комментарий)

___

## Цель

1. Знакомство с асинхронным программированием;
2. Получение практических навыков в параллельной обработке данных;
3. Получение практических навыков в синхронизации потоков.

___

## Порядок выполнения работы

* Ознакомиться с теоретическим материалом.
* Получить у преподавателя вариант задания.
* Реализовать задание своего варианта в соответствии с поставленными требованиями.
* Написать Unit-тесты с использованием Google Test.
* Создать репозиторий на GitHub.
* Отправить файлы лабораторной работы в репозиторий.
* Отчитаться по выполненной работе путём демонстрации работающей программы на тестовых наборах данных (как подготовленных самостоятельно, так и предложенных пре- подавателем) и ответов на вопросы преподавателя (как из числа контрольных, так и по реализации программы).

___

## Требования к программе

Модифицируйте вашу лабораторную работу No6 следующим образом:

- Должно быть реализовано три потока:
    - Поток, который осуществляет передвижение *NPC* на определенное расстояние (см. таблицу), а также определяет, что два *NPC* находятся на расстоянии убийства (см. таблицу). Если два NPC вступили в *"бой"*, то он создает задачу для потока, осуществляющего бои;
    - Поток, который осуществляет бои. Если один *npc* может убивать другой, то каждый *npc* "кидает 6-гранный кубик" определяя силу атаки и силу защиты (соответственно). Если сила атаки больше, чем сила защиты - то происходит убийство;
    - Мертвые *npc* не передвигаются (у нас тут без некромантов);
    - Живые *npc* не могут покинуть карту (размер задается через константы, например 100 x 100);
    - Основной поток раз в секунду печатает карту. Мертвые *npc* на карте не отображаются;
- Осуществить контроль доступа к разделяемым ресурсов с помощью *std::shared_lock* и *std::lock_guard*;
- Осуществить контроль к потоку вывода *std::cout* через *std::lock_guard*;
- Потоки могут запускаться как *std::thread* с использованием лямбда функций или функторов (классов с перегруженным оператором *operator()*);
- Вначале игры должно создаваться 50 *npc* в случайных локациях;
- Игра должна останавливаться через 30 секунд и выводить на экран список выживших.

___

### Вариант задания

|                     | Эльф | Разбойник | Медведь |
|---------------------|:----:|:---------:|:-------:|
| Расстояние хода     |  10  |    10     |    5    |
| Расстояние убийства |  50  |    10     |   10    |

___

## Сборка программы

1. После того как вы клонировали репозиторий, необходимо создать и провалиться в папку *build:*
   ```
    mkdir build
    cd build
    ```
2. Далее необходимо настроить проект на основе CMakeLists.txt:
    ```
   cmake ..
   ```
3. После успешной настройки вы можете собрать проект:
    ```
   make
   ```
4. Теперь появились 2 скомпилированные программы:
    * task07
    * tests07

5. Чтобы запустить программу:
   ```
   ./task07
   ```
   или
   ```
   ./tests07
   ```
6. Можно удалить скомпилированные программы командой:
   ```
   make clean
   ```
___

## Тесты

После компиляции программы (используя ```make```) необходимо запустить *tests07*, после выполнения программы в терминале отобразиться подробная информация о test-case.

---

## Комментарий

Учтите, что в данной лабораторной используется библиотека jsoncpp и её необходимо скачать и прописать пути в CMakeList.txt

Необходимо также установить библиотеку для вывода графического интерфейса - SFML. Не забудьте поменять пути до нее в CMakeList.txt и в main.cpp.
___